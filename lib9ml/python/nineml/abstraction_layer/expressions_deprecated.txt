


class Expression():
    # Deprecated:    
    def parse(self):
        assert False, "Deprecated, this should now be taken care of by a property: rhs"
        """ parses and checks validity of rhs """
        from nineml.abstraction_layer.expr_parse import expr_parse
        self.names, self.funcs = expr_parse(self.rhs)

class Conditional():
    def parse(self):
        assert False
        """ parses and checks validity of condtional """
        # overrides Expression.parse

        from nineml.abstraction_layer.cond_parse import cond_parse
        self.names, self.funcs = cond_parse(self.rhs)

    # Deprecated:
    def get_cond(self):
        return self.rhs
    cond = property(get_cond)


class Binding():
    def getArgs(self):
        assert False
        return self.names
    args = property(getArgs)

    def build_self(self,lhs,rhs):
        self.name = lhs
        self.rhs = rhs
        
        return 
#        import re
#        self.name, self.args, self.value =  []       
#
#
#        if self.name in math_namespace.symbols:
#            raise ValueError, "binding '%s' redefines math symbols (such as 'e','pi')" % self.as_expr()
#
#        self.parse()
#
#        if self.name in self.names:
#            raise ValueError, "Binding expression '%s': may not self reference." % self.name
#
#        # detect recursive binding
#        if self.args and self.name in self.funcs:
#            raise ValueError, "Binding expression '%s': is recursive." % self.as_expr()
#
#        # check that rhs depends on all args
#        if self.args and self.names.intersection(self.args)!=set(self.args):
#            raise ValueError, "Binding expression '%s': rhs does not depend on some of the arguments ." % self.as_expr()
#
#        # remove args from names 
#        self.names.difference_update(self.args)
#
#        if self.name in self.args:
#            raise ValueError, "Binding expression '%s': function binding has argument symbol = binding symbol." % self.name
#


def get_args(s):
    assert False
    """ return arguments of a function in a list,
    handling functions in the arguments. """

    # bracket level count
    bl = 0
    last_arg_end = 0
    args = []

    if s[0]==",":
        raise ValueError, "get_args: missing first arg."

    if s[0]==")":
        return 0,[]
    
    for i in xrange(len(s)):
        if s[i]=="(":
            bl+=1
        elif s[i]=="," and bl==0:
            args+=[s[last_arg_end:i].strip()]
            last_arg_end=i+1
        elif s[i]==")":
            if bl==0:
                args+=[s[last_arg_end:i].strip()]
                return i, args
            bl-=1
