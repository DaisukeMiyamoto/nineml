


class Expression():
    # Deprecated:    
    def parse(self):
        assert False, "Deprecated, this should now be taken care of by a property: rhs"
        """ parses and checks validity of rhs """
        from nineml.abstraction_layer.expr_parse import expr_parse
        self.names, self.funcs = expr_parse(self.rhs)

class Conditional():
    def parse(self):
        assert False
        """ parses and checks validity of condtional """
        # overrides Expression.parse

        from nineml.abstraction_layer.cond_parse import cond_parse
        self.names, self.funcs = cond_parse(self.rhs)

    # Deprecated:
    def get_cond(self):
        return self.rhs
    cond = property(get_cond)


class Binding():
    #@classmethod
    #def match(cls,s):
    #    """ Checks the syntax of the lhs to be that of a binding
    #    rhs parsing is not yet performed """
    #    print s
    #    return False

    #    try:
    #        cls.pre_parse(s)
    #    except ValueError:
    #        return False

    #    return True

    #@classmethod
    #def pre_parse(cls,s):
    #    assert False
    #    """ Determines if the lhs is a symbol binding, or function binding

    #    If symbol:

    #    return symbol, (), rhs

    #    If function:

    #    return symbol, args, rhs
    #    where args is a tuple of function argument symbols
    #    """

    #    import re
    #    
    #    if s.count(':=')!=1:
    #        raise ValueError, "Invalid binding syntax. Must contain ':=' once"

    #    lhs,rhs = s.split(":=")

    #    lhs = lhs.strip()
    #    rhs = rhs.strip()

    #    p_binding_symbol = re.compile("^[a-zA-Z_]+[a-zA-Z_0-9]*$")

    #    # not a function
    #    if p_binding_symbol.match(lhs):
    #        return lhs,(),rhs

    #    print lhs
    #    assert False
    #    # lhs matches a function?

    #    func_regex = r"[a-zA-Z_]+[a-zA-Z_0-9]*[ ]*\([ ]*([a-zA-Z_]+[a-zA-Z_0-9]*)([ ]*,[ ]*[a-zA-Z_]+[a-zA-Z_0-9]*)*[ ]*\)"

    #    p_binding_func = re.compile(func_regex)

    #    if not p_binding_func.match(lhs):
    #        raise ValueError, "Invalid binding lhs syntax '%s'. Not symbol binding, and not a function" % lhs

    #    symbol,rest = lhs.split("(")
    #    symbol = symbol.strip()

    #    args = rest.split(",")
    #    args[-1] = args[-1].replace(")","")
    #    args = [arg.strip() for arg in args]
    #    
    #    return symbol,tuple(args),rhs
    # EM: In the context of NEST and GPU code generation, bindings make sense:
    #  They are constants, i.e. a binding which takes state vars or ports in rhs
    #  should throw an exception.
    #  Users can specify them manually for eash of short hands,
    #  but automatic symbolic symplification of the expressions may well produce
    #  new bindings which can be pre-calculated outside of the integration loop.
    #
    #  Let's keep this in mind, and keep Bindings as we move forward!
    def getArgs(self):
        assert False
        return self.names
    args = property(getArgs)

    def build_self(self,lhs,rhs):
        self.name = lhs
        self.rhs = rhs
        
        return 
#        import re
#        self.name, self.args, self.value =  []       
#
#
#        if self.name in math_namespace.symbols:
#            raise ValueError, "binding '%s' redefines math symbols (such as 'e','pi')" % self.as_expr()
#
#        self.parse()
#
#        if self.name in self.names:
#            raise ValueError, "Binding expression '%s': may not self reference." % self.name
#
#        # detect recursive binding
#        if self.args and self.name in self.funcs:
#            raise ValueError, "Binding expression '%s': is recursive." % self.as_expr()
#
#        # check that rhs depends on all args
#        if self.args and self.names.intersection(self.args)!=set(self.args):
#            raise ValueError, "Binding expression '%s': rhs does not depend on some of the arguments ." % self.as_expr()
#
#        # remove args from names 
#        self.names.difference_update(self.args)
#
#        if self.name in self.args:
#            raise ValueError, "Binding expression '%s': function binding has argument symbol = binding symbol." % self.name
#

    #
    #        lhs = name
    #        rhs = self.rhs
    #
    #        for n in self.atoms:
    #            if n in prefix_excludes: continue
    #            if math_namespace.is_in_math_namespace(n): continue
    #            rhs = re.sub( r'\b%s\b'%n, prefix+n, rhs )
    #        
    #        return   Binding( lhs=lhs, rhs=rhs)

    #def name_transform_inplace_OLD(self, transform_dict ):
    #    assert False, "This needs to be pushed higher"
    #    # Note, this is IN PLACE  !!!:
    #    #argStr = ""
    #    #if self.args:
    #    #    argStr = "(%s)"%( ",".join( transform_dict.get(a,a) for a in self.args ) ) 
    #    lhs = transform_dict.get(self.name,self.name) #+ argStr

    #    rhs = self.rhs
    #    for n in itertools.chain( self.names, self.funcs): #, self.args):
    #        if math_namespace.is_in_math_namespace(n): continue
    #        if not n in transform_dict: continue
    #        rhs = re.sub( r'\b%s\b'%n, transform_dict[n], rhs )
    #    
    #    self.build_self(lhs,rhs)




Assignment:
    #def __eq__(self, other):
    #    from operator import and_

    #    if not isinstance(other, self.__class__):
    #        return False

    #    return reduce(and_, (self.name == other.name,
    #                         self.to == other.to,
    #                         self.rhs == other.expr))



    # To go:
    #@property
    #def expr(self):
    #    return self.rhs
    


    # Gone:
    #@property
    #def to(self):
    #    return self.lhs


def get_args(s):
    assert False
    """ return arguments of a function in a list,
    handling functions in the arguments. """

    # bracket level count
    bl = 0
    last_arg_end = 0
    args = []

    if s[0]==",":
        raise ValueError, "get_args: missing first arg."

    if s[0]==")":
        return 0,[]
    
    for i in xrange(len(s)):
        if s[i]=="(":
            bl+=1
        elif s[i]=="," and bl==0:
            args+=[s[last_arg_end:i].strip()]
            last_arg_end=i+1
        elif s[i]==")":
            if bl==0:
                args+=[s[last_arg_end:i].strip()]
                return i, args
            bl-=1

























#class Inplace(Equation):
#    element_name = "inplace"
#    n = 0
#    op_name_map = {'+=':'Add','-=':'Sub','*=':'Mul','/=':'Div'}
#
#    op = "+="
#    
#    def get_rhs(self):
#        return self.expr
#    def set_rhs(self,v):
#        self.expr = v
#    rhs = property(get_rhs, set_rhs)
#
#    @property
#    def lhs(self):
#        return self.to
#
#    def __init__(self, to, op, expr, name=None):
#        
#        self.to = to
#        self.op = op
#
#        # catch invalid ops and give the user feedback
#        try:
#            self.op_name = self.op_name_map[op]
#        except KeyError:
#            raise ValueError, "Unsupported inplace operation '%s', supported ops: %s" %(self.op_name, str(self.op_name_map))
#        
#        self.expr = expr
#
#        if self.to in math_namespace.symbols:
#            raise ValueError, "Inplace '%s' operates on math symbols (such as 'e','pi')" % self.as_expr()
#
#        self.name = name or ("Inplace%s%d" % (self.op_name,Inplace.n))
#        Inplace.n += 1
#        self.parse()
#
#
#    def __repr__(self):
#        return "Inplace('%s', '%s', '%s')" % (self.to,self.op,self.expr)
#
#    def as_expr(self):
#        return "%s %s %s" % (self.to,self.op, self.expr)
#
#    def as_assignment(self):
#        expr = "%s %s %s" % (self.to, self.op[0], self.expr)
#        return Assignment(self.to, expr, self.name)
#
#
#    def __eq__(self, other):
#        from operator import and_
#
#        if not isinstance(other, self.__class__):
#            return False
#
#        return reduce(and_, (self.name == other.name,
#                             self.to == other.to,
#                             self.op == other.op,
#                             self.expr == other.expr))
#
#    def to_xml(self):
#        return E(self.element_name,
#                 E("math-inline", self.expr),
#                 name=self.name,
#                 to=self.to, op=self.op)
#                 
#    @classmethod
#    def from_xml(cls, element):
#        assert element.tag == NINEML+cls.element_name
#        math = element.find(NINEML+"math-inline").text
#        return cls(to=element.get("to"), op=element.get("op"), expr=math,
#                   name=element.get("name"))
#
## factories for Inplace ops
#def InplaceAdd(to,expr):
#    return Inplace(to,'+=',expr)
#
#def InplaceSub(to,expr):
#    return Inplace(to,'-=',expr)
#
#def InplaceMul(to,expr):
#    return Inplace(to,'*=',expr)
#
#def InplaceDiv(to,expr):
#    return Inplace(to,'/=',expr)
#
